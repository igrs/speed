---
layout: default
category: caching
date: 2012-10-01
title: ブラウザキャッシュを活用する
---

## ブラウザキャッシュを活用する

原文：[https://developers.google.com/speed/docs/best-practices/caching#LeverageBrowserCaching](https://developers.google.com/speed/docs/best-practices/caching#LeverageBrowserCaching)

### Overview

静的リソースに対して`Expires`もしくは`max-age`ヘッダーを指定することで、ブラウザーがリソースをネットワーク経由からダウンロードする前にローカルディスクから読み込むことを通知させることが可能になる。

### Details

HTTP/Sはブラウザによる静的リソースのキャッシュをサポートしている。最新のブラウザー（例えばIE7、Chrome）のいくつかは明示的なキャッシュ期間がヘッダーに指定されていなくてもヒューリスティックにリソースのキャッシュ期間決定するが、他の古いブラウザーはキャッシュからリソースを読み込む前にキャッシュヘッダーを設定しておく必要がある。また一部ではSSL経由で送られるリソースはすべてキャッシュしないということもある。

すべてのブラウザーでキャッシュのメリットを最大限に享受するために、私たちは以下のことを薦める。Webサーバーに対して明示的なキャッシュヘッダーを設定し、静的なリソースをすべてキャシュ可能にする。これは画像だけのような 一部だけではない。キャッシュ可能なリソースはJS、CSSファイル、画像、他のバイナリオブジェクトファイル（メディアファイル、PDF、Flashファイル）、一般的にHTMLは静的ではないので、キャッシュを考慮すべきではない。

 HTTP/1.1は以下のキャッシュレスポンスヘッダーを提供している。


- `Expires`と`Cache-Control`: max-age.これらはリソースの”生存期間”を明示する。つまりその期間中はもし新しいバージョンがサーバーからダウンロードできても、そのチェックなしにブラウザはキャッシュを利用することが可能となる。それらは”強いキャッシュヘッダー”であり、無条件で適用される。つまりヘッダーがセットされリソースがダウンロードされているのであれば、ブラウザーは終了期間が来るまで、もしくはmax-ageが達するまでGETリクエストをしない。

- `Last-Modified`と`Etag`. これらはブラウザがファイルが同じであるかどうかチェックするのに必要な特性について明示する。`Last-Modified`ヘッダーにおいては日付で、`Etag`ヘッダーはユニークな値、一般的にファイルバージョンであったりコンテンツハッシュだ。`Last-Modified`は、ブラウザがキャッシュから読み込むか読み込まないか判断する要素で言うと”弱い”キャッシュヘッダーだ。（この決定プロセスはブラウザ毎に異なる）しかしながら、これらのヘッダーはユーザーがページ上でリロードしたときに条件付きGETリクエストブラウザにキャッシュされたリソースの効率的なアップデートをさせる。条件付きGETsはサーバー上のリソースに変化のない限りフルレスポンスを返さないので、フルGETsよりもレイテンシーを抑えることが可能だ。

すべてのキャッシュ可能なリソースにとって`Expires`もしくは`Cache-Control max-age`のひとつと`Last-Modified`もしくは`Etag<`のひとつを明示するのはとても重要なことだ。加えて、`Expires`と`Cache-Control max-age`、もしくは`Last-Modified`と`Etag`の両方を一緒に明示することは冗長だ。


### Recommendations

__すべての静的リソースに対して積極的にキャッシュヘッダーを設定する __  
すべてのキャッシュ可能なリソースのために以下の設定を推奨する：

- 最低1ヶ月以上、1年が好ましいが未来の日付を`Expires`で設定する（私たちは`Cache-Control max-age`よりも`Expires`の設定を好ましいと考えている。なぜなら、それはより多くの環境でサポートされているからだ）。また、RFCのガイドライン上、1年以上の期限を設定すべきではない。近日中にリソースの変更予定が確実にあるのならば、短い期限に設定しても問題ないだろう。しかし、”まもなく変更するかもしれない”、もしくは分からないといった場合は長い期限を設定すべきだ。また、URLフィンガープリント（後述参照）を使用する。積極的なキャッシュの設定は私たちの知る限りブラウザーに対して何の悪影響を及ぼさない。すべてのブラウザーは最低使用頻度（LRU）アルゴリズムにもとづいて、キャッシュをクリアしている。あなたは気づいてないかもしれないが、どのブラウザーもキャッシュクリアする前はリソースの期限が切れるのを待っているのだ。

- `Last-Modified`の日付をリソースが変更された日に設定する。もし、`Last-Modified`の日付が必要以上に昔に設定されていたのであればブラウザは再取得する可能性はないだろう。

__動的キャッシュを有効にするためにフィンガープリントを使用する __  
時々変更するリソースにとって、ブラウザはサーバー上で変更があるまでそのリソースをキャッシュすることが可能だ。変更の際はサーバーがブラウザに対して新しいバージョンがあることを通知してくれる。あなたはリソースに対してフィンガープリントを埋め込むことができる。ここで言うフィンガープリントとは例えばファイルパスのようなURLのことだ。リソースを変更する場合、同様にフィンガープリントも変更する、つまりURLを変更するのです。URLが変更になるとブラウザーは強制的にリソースを再取得する。フィンガープリントは遠い未来に`Expires`を設定しつつもリソースが頻繁に変更するようなケースにおいて有用だ。もちろん、このテクニックはリソースを参照しているすべてのページでフィンガープリントされたURLを使わなければならない。それはどのようにページがコーディングされているかによって、実装の難易度は違ってくる。

__IEのためにVaryヘッダーを設定する __  
インターネットエクスプローラーはVaryヘッダーが設定してある（Accept-EncodingとUser-Agentのフィールドは除いて）いかなるリソースもキャッシュしない。IEでキャッシュされることを保証するために、Varyヘッダーからフィールドを全て削除するか、Varyヘッダー自体、削除しているか確認する。

__Firefoxでキャッシュ衝突を引き起こすURLは避ける__  
Firefoxのディスクキャッシュのハッシュ関数はURLの衝突を生成してしまう。それはわずかしか違わない、つまり8文字のボーダーラインだ。リソースハッシュが同じキーの場合、リソースはその中で一つしか保存されない。同じキーを持った残りのリソースはブラウザの再起動後、再読み込みしなければならない。つまり、もしあなたがフィンガープリントを使用している、もしくはそれにかわるプログラム的にファイルURLを生成しているのであれば、キャッシュを最大限利用するために、アプリケーションが生成するURLを8文字以上にすることでFirefoxのハッシュ衝突を避けるべきだ。

__FirefoxでHTTPSキャッシュを有効にするために Cache control: publicディレクティブを使用する__  
Firefoxのいくつかのバージョンによっては、たとえ他のキャッシュヘッダーが明示的に指定されていようともSSL経由のリソースをディスクキャッシュさせるためにCache control: publicヘッダーを設定する必要がある。このヘッダーは通常プロキシーサーバー（後述）のキャッシュを有効化するために使用されるものだが、プロキシーはHTTPS経由のコンテンツをキャッシュできないので、HTTPSリソースのためにも常にこのヘッダーを設定しておいたほうが無難だ。

### Example

ログイン後に表示するユーザーカレンダー用のCSSに対して、Google Calendarはファイル名にフィンガープリントを実装している。calendar/static/fingerprint_keydoozercompiled.css,フィンガープリントキーは128ビットの16進数だ。スクリーンショット（Page SpeedのShow Resourcesパネルから）は以下。フィンガープリントキーは 82b6bc440914c01297b99b4bca641a5だ。

![](https://developers.google.com/speed/docs/insights/images/cachingheader1.png)

フィンガープリントの仕組みのおかげで、`Expires`ヘッダは1年後に設定でき、`Last-Modified`はファイルが更新されて日付で設定でき、Cache-Control: max-ageヘッダーは3153600に設定可能だ。有効期限前にファイルが変更されたケースでもクライアントが再ダウンロードできるように、フィンガープリント、つまりURLを変更することでファイルは必ず再読込される。

### Additional resources

- HTTPキャッシュの詳細な説明に関しては、[HTTP/1.1 RFC](http://www.w3.org/Protocols/rfc2616/rfc2616.html), sections [13.2](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.2), [14.21](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec14.21), and [14.9.3](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec14.9.3)
- Apacheにおけるキャッシュ有効化に関しては [Apache Cache Guide](http://httpd.apache.org/docs/2.2/caching.html)