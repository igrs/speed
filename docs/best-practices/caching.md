# キャッシュの最適化

多くのWebページは、CSSや画像、JavaScriptなどのような、それほど変更のないリソースを含んでいる。これらのリソースをネットワーク経由でダウンロードすることは時間のかかることであり、つまりページの読み込み時間を増加させてしまう。ブラウザ・プロキシーキャッシュなどのHTTPキャッシュさせることで、これらのリソースを保存もしくはキャッシュさせることができる。リソースをキャッシュしてしまえば、リピートビューでダウンロードされるリソースの代わりに、ブラウザもしくはプロキシーはローカルのキャッシュされたリソースを参照することができる。つまり、キャッシュは二重の意味で有効です。1つは必要なリソースのHTTPリクエストを削減できることでラウンドトリップ回数を減らすことができます。2つめは、レスポンスの総ペイロードサイズを削減することができます。そのうえ、リピートビューでの読み込み時間を劇的に減少させるだけでなく、ホスティングコストや帯域幅の節約にもつながる。

+ [ブラウザキャッシュを活用する](#ブラウザキャッシュを活用する)
+ [プロキシーキャッシュを活用する](#プロキシーキャッシュを活用する)

## ブラウザキャッシュを活用する

### 概要

静的リソースに対して`Expires`もしくは`max-age`ヘッダーを指定することで、ブラウザがリソースをネットワーク経由からダウンロードする前にローカルディスクから読み込むことを通知させることが可能になる。

### 詳細

HTTP/Sはブラウザによる静的リソースのキャッシュをサポートしている。最新のブラウザ（例えばIE7、Chrome）のいくつかは明示的なキャッシュ期間がヘッダーに指定されていなくてもヒューリスティックにリソースのキャッシュ期間決定するが、他の古いブラウザはキャッシュからリソースを読み込む前にキャッシュヘッダーを設定しておく必要がある。また一部ではSSL経由で送られるリソースはすべてキャッシュしないということもある。

すべてのブラウザでキャッシュのメリットを最大限に享受するために、私たちは以下のことを薦める。Webサーバーに対して明示的なキャッシュヘッダーを設定し、静的なリソースをすべてキャシュ可能にする。これは画像だけのような 一部だけではない。キャッシュ可能なリソースはJS、CSSファイル、画像、他のバイナリオブジェクトファイル（メディアファイル、PDF、Flashファイル）、一般的にHTMLは静的ではないので、キャッシュを考慮すべきではない。

 HTTP/1.1は以下のキャッシュレスポンスヘッダーを提供している。

- `Expires`と`Cache-Control`: max-age.これらはリソースの”生存期間”を明示する。つまりその期間中はもし新しいバージョンがサーバーからダウンロードできても、そのチェックなしにブラウザはキャッシュを利用することが可能となる。それらは”強いキャッシュヘッダー”であり、無条件で適用される。つまりヘッダーがセットされリソースがダウンロードされているのであれば、ブラウザは終了期間が来るまで、もしくはmax-ageが達するまでGETリクエストをしない。

- `Last-Modified`と`Etag`. これらはブラウザがファイルが同じであるかどうかチェックするのに必要な特性について明示する。`Last-Modified`ヘッダーにおいては日付で、`Etag`ヘッダーはユニークな値、一般的にファイルバージョンであったりコンテンツハッシュだ。`Last-Modified`は、ブラウザがキャッシュから読み込むか読み込まないか判断する要素で言うと”弱い”キャッシュヘッダーだ。（この決定プロセスはブラウザ毎に異なる）しかしながら、これらのヘッダーはユーザーがページ上でリロードしたときに条件付きGETリクエストブラウザにキャッシュされたリソースの効率的なアップデートをさせる。条件付きGETsはサーバー上のリソースに変化のない限りフルレスポンスを返さないので、フルGETsよりもレイテンシーを抑えることが可能だ。

すべてのキャッシュ可能なリソースにとって`Expires`もしくは`Cache-Control max-age`のひとつと`Last-Modified`もしくは`Etag<`のひとつを明示するのはとても重要なことだ。加えて、`Expires`と`Cache-Control max-age`、もしくは`Last-Modified`と`Etag`の両方を一緒に明示することは冗長だ。

### 推奨

__すべての静的リソースに対して積極的にキャッシュヘッダーを設定する __  
すべてのキャッシュ可能なリソースのために以下の設定を推奨する：

- 最低1ヶ月以上、1年が好ましいが未来の日付を`Expires`で設定する（私たちは`Cache-Control max-age`よりも`Expires`の設定を好ましいと考えている。なぜなら、それはより多くの環境でサポートされているからだ）。また、RFCのガイドライン上、1年以上の期限を設定すべきではない。近日中にリソースの変更予定が確実にあるのならば、短い期限に設定しても問題ないだろう。しかし、”まもなく変更するかもしれない”、もしくは分からないといった場合は長い期限を設定すべきだ。また、URLフィンガープリント（後述参照）を使用する。積極的なキャッシュの設定は私たちの知る限りブラウザに対して何の悪影響を及ぼさない。すべてのブラウザは最低使用頻度（LRU）アルゴリズムにもとづいて、キャッシュをクリアしている。あなたは気づいてないかもしれないが、どのブラウザもキャッシュクリアする前はリソースの期限が切れるのを待っているのだ。

- `Last-Modified`の日付をリソースが変更された日に設定する。もし、`Last-Modified`の日付が必要以上に昔に設定されていたのであればブラウザは再取得する可能性はないだろう。

__動的キャッシュを有効にするためにフィンガープリントを使用する __  
時々変更するリソースにとって、ブラウザはサーバー上で変更があるまでそのリソースをキャッシュすることが可能だ。変更の際はサーバーがブラウザに対して新しいバージョンがあることを通知してくれる。あなたはリソースに対してフィンガープリントを埋め込むことができる。ここで言うフィンガープリントとは例えばファイルパスのようなURLのことだ。リソースを変更する場合、同様にフィンガープリントも変更する、つまりURLを変更するのです。URLが変更になるとブラウザは強制的にリソースを再取得する。フィンガープリントは遠い未来に`Expires`を設定しつつもリソースが頻繁に変更するようなケースにおいて有用だ。もちろん、このテクニックはリソースを参照しているすべてのページでフィンガープリントされたURLを使わなければならない。それはどのようにページがコーディングされているかによって、実装の難易度は違ってくる。

__IEのためにVaryヘッダーを設定する __  
インターネットエクスプローラーはVaryヘッダーが設定してある（Accept-EncodingとUser-Agentのフィールドは除いて）いかなるリソースもキャッシュしない。IEでキャッシュされることを保証するために、Varyヘッダーからフィールドを全て削除するか、Varyヘッダー自体、削除しているか確認する。

__Firefoxでキャッシュ衝突を引き起こすURLは避ける__  
Firefoxのディスクキャッシュのハッシュ関数はURLの衝突を生成してしまう。それはわずかしか違わない、つまり8文字のボーダーラインだ。リソースハッシュが同じキーの場合、リソースはその中で一つしか保存されない。同じキーを持った残りのリソースはブラウザの再起動後、再読み込みしなければならない。つまり、もしあなたがフィンガープリントを使用している、もしくはそれにかわるプログラム的にファイルURLを生成しているのであれば、キャッシュを最大限利用するために、アプリケーションが生成するURLを8文字以上にすることでFirefoxのハッシュ衝突を避けるべきだ。

__FirefoxでHTTPSキャッシュを有効にするために Cache control: publicディレクティブを使用する__  
Firefoxのいくつかのバージョンによっては、たとえ他のキャッシュヘッダーが明示的に指定されていようともSSL経由のリソースをディスクキャッシュさせるためにCache control: publicヘッダーを設定する必要がある。このヘッダーは通常プロキシーサーバー（後述）のキャッシュを有効化するために使用されるものだが、プロキシーはHTTPS経由のコンテンツをキャッシュできないので、HTTPSリソースのためにも常にこのヘッダーを設定しておいたほうが無難だ。

### 事例

ログイン後に表示するユーザーカレンダー用のCSSに対して、Google Calendarはファイル名にフィンガープリントを実装している。calendar/static/fingerprint_keydoozercompiled.css,フィンガープリントキーは128ビットの16進数だ。スクリーンショット（Page SpeedのShow Resourcesパネルから）は以下。フィンガープリントキーは 82b6bc440914c01297b99b4bca641a5だ。

![](https://developers.google.com/speed/docs/insights/images/cachingheader1.png)

フィンガープリントの仕組みのおかげで、`Expires`ヘッダは1年後に設定でき、`Last-Modified`はファイルが更新されて日付で設定でき、Cache-Control: max-ageヘッダーは3153600に設定可能だ。有効期限前にファイルが変更されたケースでもクライアントが再ダウンロードできるように、フィンガープリント、つまりURLを変更することでファイルは必ず再読込される。

### その他のリソース

- HTTPキャッシュの詳細な説明に関しては、[HTTP/1.1 RFC](http://www.w3.org/Protocols/rfc2616/rfc2616.html), sections [13.2](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.2), [14.21](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec14.21), and [14.9.3](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec14.9.3)
- Apacheにおけるキャッシュ有効化に関しては [Apache Cache Guide](http://httpd.apache.org/docs/2.2/caching.html)


## プロキシーキャッシュを活用する

### 概要

公開キャッシュを有効化することで、ブラウザに対して遠くのオリジンサーバーよりも近くのプロキシーサーバーからリソースのダウンロードが可能になる。

### 詳細

ブラウザキャッシュに加えて、HTTPはプロキシーキャッシュも提供している。これは静的なリソースをパブリックなWebプロキシーサーバーでキャッシュさせることができる。最も有名なものとしてはISPのサーバーを利用するといったことが考えられる。これは最初の訪問でもキャッシュの利益を享受することができるということだ。あるユーザーからプロキシーを通して一度でもリクエストされたのであれば、そのリソースは同じプロキシーを通してリクエストする全てのユーザーで利用できるようになる。これらのプロキシーを利用する場合、サーバーよりもユーザーに地理的に近いため、プロキシーキャッシュはレイテンシーを削減することが可能だ。もし、プロキシーを有効に活用できればあなたのサーバーの帯域幅を全く利用せずにプロキシーからリソースは適用されるので、無料でWebサイトをホスティングできるだろう。

`Cache-control: public`ヘッダーを設定することでリソースをブラウザキャッシュに加えて、公開プロキシーサーバーにもキャッシュさせておくことができ、リクエストの問題を解決することができるだろう。例外（後述）を除いて、あなたのWebサーバーにはリソースをキャッシュさせるために`public`ヘッダーを設定する。

### 推奨

__静的リソースURLにクエリー文字列をつけない__  
多くのプロキシー、その中でも最も有名なSquid Ver3.0において、"?"の文字列のついたリソースは、たとえ`Cache-control: public`を指定していてもリソースはキャッシュされない。これらのリソースをプロキシーキャッシュさせるためには、静的リソースからクエリー文字列を取り除くことが必要で、代わりにファイルネームに対してエンコードしたパラメータを付ければ問題ない。

__クッキーがセットされたリソースに対してプロキシーキャッシュさせない__  
パブリックにリソースをキャッシュし複数のユーザーで共有する場合、それはリソースにセットされたクッキーも共有すると同じ事です。多くのプロキシーがクッキーがセットされたリソースをキャッシュしないでもない限り、このリスクは避けたほうが良いでしょう。`Cache-control:`を`private`に設定するか、[クッキーレスなドメインから](/docs/best-practices/request.md#静的コンテンツはクッキーレスドメインから提供する)リソースを配信すべきでしょう。

__JavaScript/CSSファイルのプロキシーキャッシュについての問題に注意する__  
いくつかの公開プロキシーは`Content-Encoding`レスポンスヘッダーを検出しないバグを持っているため、圧縮ファイルを適切に展開できないブラウザに対しても、圧縮ファイルを送信してしまう恐れがある。これらのファイルはあなたのサーバーによって常に[Gzip](/docs/best-practices/payload.md#圧縮を有効にする)されるべきなので、クライアントが正確に理解できるか確かめる必要があり、次のいずれかの対策をするとよい:

+ `Cache-Control`ヘッダーを`private`に設定する。こうすることでリソースのプロキシーキャッシュを無効にできる。あなたのアプリケーションが世界中で提供され、ユーザーローカリティのためにプロキシーキャッシュの依存を抑えたいのなら、この設定が適切かもしれない。
+ レスポンスヘッダーに`Vary: Accept-Encoding`を指定する。この指示はプロキシーに対してリソースを2つのバージョンで保存することを意味しており、1つは圧縮されたリソースで、もう1つは未圧縮なものだ。リソースの正しいバージョンはクライアントのリクエストヘッダーにもとづいて配信される。これはシングルホームなネットワーク、またはユーザー局所的なパブリックプロキシーに依存しているアプリケーションにとって良い選択と言える。

---

原文：https://developers.google.com/speed/docs/best-practices/caching